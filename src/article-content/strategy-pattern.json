[
  {
    "id": 1,
    "components": [
      {
        "type": "heading",
        "value": "What is Strategy Pattern?"
      },
      {
        "type": "paragraph",
        "value":
          "According to wikipedia, Strategy pattern is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use"
      },
      {
        "type": "paragraph",
        "value":
          "This means that an object will have a certain strategy/algorithm, which can be easily injected into it, and that can initialize it's behaviour at the time of creation, or change during runtime."
      }
    ]
  },
  {
    "id": 2,
    "components": [
      {
        "type": "heading",
        "value": "Let's dive into a problem statement"
      },
      {
        "type": "paragraph",
        "value":
          "We have a bunch of Duck subclasses that are derived from a super class Duck(Structure below) If we wish to add fly method in CityDuck and WildDuck, we will create a method fly in Duck. So far so good."
      },
      {
        "type": "paragraph",
        "value":
          "But if someone creates a new subclass RubberDuck, then we might fall into some issues. This new class RubberDuck cannot fly, and therefore, the best bet would be to override fly method in Rubberduck to do nothing."
      },
      {
        "type": "paragraph",
        "value":
          "Lets add more fun to the problem, you boss wants you to add WoddenDuck too. Now this WoodenDuck can;t swim, can't fly. We will have to override both the methods to make WoddenDuck not swim and not fly"
      },
      {
        "type": "paragraph",
        "value":
          "This may go on and on with many more methods to be added in Duck class, and each time a new method is added, we will ahve to check if overriding the superclass behaviour is required in few subclasses or not. This can be a real pain of we have may subclass. We are also duplicating a lot of code in making RubberDuck and WoodenDuck not fly."
      },
      {
        "type": "paragraph",
        "value":
          "Inheritance is becoming a mess and we are left with lot of duplicate code."
      }
    ]
  },
  {
    "id": 3,
    "components": [
      {
        "type": "heading",
        "value": "The solution"
      },
      {
        "type": "paragraph",
        "value":
          "Enters the Strategy Pattern. As per the definition, lets make aur class select algorithms at runtime. In our case, fly and swim can be of different algorithms/strategies/behaviour. Instead of passing them as Is-A relationship from parent to child, lets give these behaviours with Has-A relationship."
      },
      {
        "type": "paragraph",
        "value":
          " we create an Interface IFlyBehaviour and ISwimBehaviour, and use them as variables in our Duck class. IFlyBehaviour may have multiple implementations such as FlyingHighBehavior and NoFlyBehaviour. Same with ISwimBehaviour code below."
      },
      {
        "type": "code",
        "value": [
          "public interface IFlyBehaviour {",
          "    public void fly();",
          "}"
        ]
      },
      {
        "type": "paragraph",
        "value":
          "now instead of creating different duck classes, we can have a single duck class with behaviour/strategis than can be easily pluged into them.If we create setters for these strategies, then we can change the behaviour at runtime."
      }
    ]
  },
  {
    "id": 4,
    "components": [
      {
        "type": "heading",
        "value": "Other examples"
      },
      {
        "type": "paragraph",
        "value":
          "Sorting arrays can have different strategy. Charging a customer based on the time of the day. Day charges and night charges."
      }
    ]
  },
  {
    "id": 5,
    "components": [
      {
        "type": "heading",
        "value": "Conclusion"
      },
      {
        "type": "paragraph",
        "value": "TODO"
      }
    ]
  }
]
